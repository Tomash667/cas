? ctor tests for diffrent types (void, int, string, class); ctor in ParseLine makes no sense and require ; - what about "A(1) += 4;"

IMPROVEMENT/VERIFY:
+ ParseConstExpr in switch, default arg value
+ ParseFunctionArgs -> ParseConstExpr
+ set_tmp reference (string?), check string references
+ remove duplicates in string table
+ signaling parse/run thread to exit, not using TerminateThread
+ map of casts
+ checking for return value in {for/do/while} currently this will return error
	int f()
	{
		while(true)
			return 1;
	}
+ push_this is like push_arg 0 - maybe move all arguments by 1 (first arg = 0)
+ catch all exceptions in tests/runner
+ better handling for parse functions for code type
+ optimize operations on reference to struct, currently it will use deref on every usage
+ reference types (temporary, member, global)
+ better line markers, option in settings
+ Assert_AreEqual(T,T)
+ return reference to passed class/struct/string member/index
+ type_index - bit for class/struct
+ better Type* handling, not passing magic index
+ remove not required interactions between Module/Parser and Decompile/Parser (for example ParserMethod/FindEqualFunction should be inside RegisterMethod)
+ register virtual function or else (sizeof(ptr) != sizeof(void*))
+ checking ref counter on cleanup for string
+ allow vars with same name as function
+ better class/struct offset (push_member type offset)
+ += should call + and = if compound not found
+ optimize string concat (currently a+=b will create new string with a+b, then assign to a)
+ member initialization const expr
+ remove double ret at end of main
+ code constructor create copy two instance and then copy value from one to another

FEATURE:
+ overload pre/post ++ --
+ nullable?
+ ++-- returns reference
+ extension methods
+ named parameters
+ nested class
	+ forward nested class usage
+ enum
	+ inside function/block
	+ inside class
+ class protection level (public/protected/private)
+ array
	+ functions (count, push, pop, front, back-with argument return n last element, insert, erase, at, empty)
	+ const size
	+ braces initialization
	+ for each
	+ operator []
	+ variadic functions (params)
+ entry point, run function/method
+ get list of globals, get/set global value
+ class/struct return value
+ return new class instance without constructor [class X{} X f() { return ???}] ??? = X
+ register global
+ exceptions, try/catch
	+ AssertException
+ AddFunction/Method optional parameter name
+ local functions
	void f()
	{
		int a;
		void f2()
		{
			a = 3;
		}
		f2();
	}
+ allow var decl in switch case without braces
+ delegate/callback
+ dictionary/map
+ const
	+ "string" are const
+ superbreak
+ && || short circuiting
+ multiline string
+ ref arg default value
+ namespace
+ [VEC3 pos; float rot] GetPos()
	{
		return [pos = my_pos, rot = my_rot];
	}
	unnamed struct
+ class
	+ static constructor
	+ static destructor
	+ static member
	+ string member
	+ class member (detect recursion), allow declare member of same type as class (but prevent it until nullable type, just don't show error of unknown item)
		+ member ctor decl
	+ properties
	+ default value for class argument in function
	+ inhertiance
	+ interfaces
	+ allow call ctor from ctor
+ is operator
	+ compare object and type if(a is INT2)
+ default string arg for code function
+ string oper
+ allow reuse variable name
+ object/string deconstruction
+ warn about implict cast (setting)
+ warn about div by 0 in const
+ opt: print(4) -> converted to string
+ warn: use of unassigned variable
+ string functions, substr, first(), last(), trim
+ function constexpr (abs,cin,cos)
+ in - if(x in {3,5})
+ switch ext
	+ jmp table
	+ multivar, range (case 0..30,42:)
	+ class
	+ complex - dynamic var - no jmp table!
	+ optimization - jmp table
	+ VerifyNodeReturnValue on complete types (bool, enum), no default required
	+ invalid case type failure test
+ $opCmp (-1 smaller, 0 equal, 1 greater) - can be used instead of overriding == != > >= < <=
+ use == / != and negate if other is defined
+ optimize multiple conditions (- -a), if(!(a != b))
+ allow to turn off optimize const expr
+ detect unreachable code
+ object
	+ type var, get_type()
+ typeid
+ multiple files/modules (sharing classes, globals - current globals-> 0 level locals)
+ parse optimizations:
	+ store functions in map[string] -> vector<Func>
+ union?
+ optimize:
	+ remove unused function
	+ remove unreachable code
	+ remove call to function without side effects
	+ don't initialize members that won't be used until overwritten
	+ TryConstExpr for IS
	+ exclude functions without side effects or empty and don't call them
	+ first/second pass do same thing twice for parsing func args
	+ get rid of many GetType...
	+ operator += cause [push_global 0, push_global 0] instead of [push_global 0, push]
+ shorter class initialization: A b(3,4) ?
+ await/async for spawning units
	+ wait for spawn
	+ spawn instantly
	+ don't wait
+ stdlib
	+ math: random, rand, floor, ceil, round, abs, sin, cos
+ runner OO
+ less makroed test framework
+ decompile redirect
+ allow same name class X { ErrorCode ErrorCode; } ?
+ CommonType user cast
+ other cast operator (float)x
+ better error message [dupa();] currently "unknown item dupa", new "no function 'dupa()' found"
+ ref to thing that needs subtype

DEBUG:
+ debug file marker, like LINE but FILE index to str
+ file/line/function on assert/crash
+ allow multiple errors, continue parsing after error
+ deassembly labels
+ code in disassembly
+ remove builtin functions from disasembly
+ debugger
+ include code in decompile
+ decompiler - calculate next function offset
