--> long assign

+ generate default ctor
+ generate default equal
	+ == can be overloaded, compare by value or address by default
	+ is can't be overloaded only for ref
		+ failure test

NEW TODO ORDER:
1) VALUE TYPE
var a = b; // copy value of b into a (use cast/ctor/assign)

if(a == b) // compare value (by default)

REFERENCE TYPE
var a = b; // copy address of b into a, both points to same instance

if(a == b) // compare address (by default)

REF VAR
struct& a = b; // copy value

class& a = ...;
a = b; // a points to b

class& a;
if(a == b) // compare address of a with address of b (not ref address)

struct& a;
if(a == b) // compare value

is - any purpose for it now ?

2) string is struct + tests
3) nullable?
4) script arg/ret ref

- struct_class_ref.txt

+ modify string reference (execution error)
++-- returns reference

? verify if ParseExpr type is longer used
? parse class func checks FindEqualFunction without type

+ ParseFunctionArgs -> ParseConstExpr
+ subscript
+ subscript with multiple items
+ overload pre/post ++ --
+ set_tmp reference (string?), check string references
+ string oper

? ctor tests for diffrent types (void, int, string, class); ctor in ParseLine makes no sense and require ; - what about "A(1) += 4;"

- c++ function returning string cause 1 byte memory leak (string.txt)
- many memory leaks in user_func, func_def_params, def_value, class, func_overload, script_class, script_class_func, is, ref, class_ref, cast, struct, subscript
- ParseExpr end/end2 is unused
- ParseNode::str cleanup
- class A { void int; } cause Member of 'void' type not allowed.
- code constructor create copy two instance and then copy value from one to another
- missing member for type x/func - memory leak of string

NEST A STRING:
+ raise error
+ */ -> Not opened multiline comment found instead of unexpected *.
+ entry point
+ improvments
+ array

TODO:
register class/struct
verify
norefcount
noinstance

+ for struct marking as need copy, push as reference to other function, need testing (and working reference system)
	struct X{ int a; }
	void f(X x)
	{
		f2(x); // should mark?
		f3(x.a); // ^
	}
	void f2(X& x) {}
	void f3(int& x) {}

+ register member function as member func
+ return new class instance without constructor [class X{} X f() { return ???}] ??? = X
+ allow overload operator for builtin types, currently it only works for class (this will need mixing with existing operator, and checking for builtin)
+ string operator (+ string,char +=)

- CObj b1, b7(7); not allowed, why? (this syntax is not allowed, require b7 = CObj(7), need fix)
+ AssertException
+ non instanceable class
+ register global
+ thiscall ctor

+ AddFunction/Method optional parameter name
+ register virtual function or else (sizeof(ptr) != sizeof(void*))
+ checking ref counter on cleanup for string
+ allow vars with same name as function
+ better Type* handling, not passing magic index
+ remove not required interactions between Module/Parser and Decompile/Parser (for example ParserMethod/FindEqualFunction should be inside RegisterMethod)
+ [VEC3 pos; float rot] GetPos()
	{
		return [pos = my_pos, rot = my_rot];
	}
	unnamed struct
+ allow to set member value outside of constructor like in c# [class X {int a = 4;}]

+ array
vector functions:
	count
	push
	pop
	front
	back
	insert
	erase
	at
	empty
	+ const size
	+ braces initialization
	+ for each
	+ operator []

+ variadic functions (params)
+ signaling parse/run thread to exit, not using TerminateThread

+ class
	+ dtor
	+ string member
	+ class member (detect recursion), allow declare member of same type as class (but prevent it until nullable type, just don't show error of unknown item)
	+ properties
	+ default value for class argument in function
	+ copy ctor (default)
	+ inhertiance
	+ interfaces

+ is operator
	+ compare object and type if(a is INT2)
+ default string for code function
+ allow reuse variable name
+ object/string deconstruction
+ warn about implict cast (setting)
+ no memleaks
+ warn about div by 0 in const
+ opt: print(4) -> converted to string
+ warn: use of unassigned variable
+ string functions, substr, first(), last(), trim, clear
+ function constexpr (abs,cin,cos)
+ namespace
+ in - if(x in {3,5})
+ switch ext
	+ multivar, range (case 0..30,42:)
	+ class
	+ complex - dynamic var - no jmp table!
	+ optimization - jmp table
	+ VerifyNodeReturnValue on complete types (bool, enum), no default required
	+ invalid case type failure test
+ $opCmp (-1 smaller, 0 equal, 1 greater) - can be used instead of overriding == != > >= < <=
+ use == / != and negate if other is defined
+ optimize multiple conditions (- -a), if(!(a != b))
+ allow to turn off optimize const expr
+ superbreak
+ detect unreachable code
+ const
+ advanced function default params (using expr not const_item)
+ object
	+ type var, get_type()
+ register function thiscall
+ typeid
+ static type functions
+ register c++ global
+ enum
+ register enum
+ multiple files/modules (sharing classes, globals - current globals-> 0 level locals)
+ types
	+ dictionary/map
+ parse optimizations:
	+ store functions in map[string] -> vector<Func>
+ delegate/callback
+ union?
+ optimize:
	+ remove unused function
	+ remove unreachable code
	+ remove call to function without side effects
	+ don't initialize members that won't be used until overwritten
	+ TryConstExpr for IS
	+ exclude functions without side effects or empty and don't call them
	+ first/second pass do same thing twice for parsing func args
+ && || short circuiting
+ remove duplicates in string table
+ shorter class initialization: A b(3,4) ?
+ await/async for spawning units
	+ wait for spawn
	+ spawn instantly
	+ don't wait
+ stdlib
	+ math: random, rand, floor, ceil, round, abs, sin, cos
+ include code in decompile
+ ref arg default value
+ multiline string

calling conventions
http://www.angelcode.com/dev/callconv/callconv.html
return value
	+ bool, int, float, string
	+ by ref
	+ by pointer
	+ array
	+ with constr
	+ with assignment
	+ with destructor
	
array, ctor, dtor, assign, > 2 (>4 x64) - return in memory
else return in reg

+ runner OO
+ less makroed test framework
+ different syntax
	var type = module->AddType();
	type->AddMember();
+ decompile redirect
+ allow same name class X { ErrorCode ErrorCode; } ?
+ exceptions, try catch
+ complex subscript: map[1,2]
+ checking for return value in {for/do/while} currently this will return error
	int f()
	{
		while(true)
			return 1;
	}
+ CommonType user cast
+ other cast operator (float)x
+ better error message [dupa();] currently "unknown item dupa", new "no function 'dupa()' found"
+ "string" are const
+ debug
	+ file/line/function on assert/crash
	+ allow multiple errors, continue parsing after error
	+ line numbers in debug (for assert)
	+ deassembly labels
+ delete default operators
+ ref to thing that needs subtype
+ push_this is like push_arg 0 - maybe move all arguments by 1 (first arg = 0)
