//==============================================================================
// ref ops get (deref)
int ref_get(int& a)
{
	return a;
	// push_arg 0
	// deref
	// ret
}
void ref_get_test()
{
	int a = 3;
	int r = ref_get(a);
	Assert_AreEqual(3, r);
}
ref_get_test();

//==============================================================================
// ref ops set (set_adr)
int ref_set(int& a)
{
	return a = 4;
	// push_arg 0
	// push_int 4
	// set_adr
	// ret
}
void ref_set_test()
{
	int a = 3;
	int r = ref_set(a);
	Assert_AreEqual(4, a);
	Assert_AreEqual(4, r);
}
void ref_set_test();

//==============================================================================
// ref ops set from ref (set_adr deref)
int ref_set_from_ref(int& a, int& b)
{
	return a = b;
	// push_arg 0
	// push_arg 1
	// deref
	// set_adr
	// ret
}
void ref_set_from_ref_test()
{
	int a = 5;
	int b = 7;
	int r = ref_set_from_ref(a, b);
	Assert_AreEqual(7, a);
	Assert_AreEqual(7, r);
}

//==============================================================================
// ref ops compound
int ref_compound(int& a)
{
	return a += 2;
	// push_local a adada!!!!!!!!!!!!!
}

//==============================================================================
// arg ref to global
int global;
f(global);
Assert_AreEqual(4,)

/*
arg
void f(int& x){}

1. arg ref to global
int a;
f(a);

push_global_ref 0
callu f

2. arg ref to local
void f2()
{
	int a;
	f(a);
	
	push_local_ref 0
	callu f
	ret <- invalidate ref
}
f2();

callu f2

3. arg ref to arg
void f2(int a)
{
	f(a);
	
	push_arg_ref 0
	callu f
	ret <- invalidate ref
}
f2(3);

push_int 3
callu f2

4. arg ref to member
class X
{
	int a;
}

X x;
f(x.a);

ctor X
set_local 0
pop
push_local 0
push_member_ref 0 // inc ref to class
callu f

5. arg ref to this member

class X
{
	int a;
	void f2()
	{
		f(a);
		
		push_this_member_ref 0 // inc ref to class
		callu f
		ret
	}
}

X x;
x.f2();

ctor X
set_local 0
pop
push_local 0
callu X.f2

6. arg res to index

char& operator [] (int index);

string str = "aaa";
void f(char& c){}
f(str[0]);

push_local 0
push_int 0
call string.$opIndex
callu f

================================================================================
*** ref ops
get
set
compound
pre inc
post inc
index

*** return ref
*** var ref
*** script arg ref
*** script return ref
*** out of scope

arg
int? ra;
void set_n_change(int& r)
{
	r = 1;
	ra -> r;
}
void f(int a)
{
	set_n_change(a);
	Assert_AreEqual(1, a);
}
f(0);
ra = 2;

local
member
this_member
index


push member of return value

struct X
{
	int x;
}

X gx;
X& get()
{
	return gx;
	//push_global_ref 0
	//ret
}

void f(int& a)
{
	a = 3;
	//push_local 0
	//push_int 3
	//set_adr
	//pop
	//ret
}

f(get().x);
//callu get <- source StructReturnValue?, nie dla referencji ma nie byÄ‡ bo operujesz na tym samym obiekcie!
//push_member_ref 0
//callu f

Assert_AreEqual(3, gx.x);

*/