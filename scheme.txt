code:
	[ line_or_block ... ] EOF

func_decl:
	var_type <func_name> arg_decl EOF
	<class_name> arg_decl EOF // ctor
	operator addref/release () // special function

func_def:
	var_type <func_name> arg_decl block
	<class_name> arg_decl block // ctor

member_decl:
	simple_var_type <member_name> EOF

line_or_block:
	block
	line

block:
	{ [ line_or_block ...] }
	
line:
	class/struct <class_name> { [class_item ...] }
	func_def // can only be used in top block
	if cond line_or_block [ else line_or_block ]
	do line_or_block while cond ;
	while cond line_or_block
	for ( [ var_type_decl / expr ] ; [ expr ] ; [ expr ] ) line_or_block
	var_type_decl ;
	break ;  // must be inside loop block
	return [expr] ;
	expr ;
	;

class_item:
	simple_var_type <member_name> [, <member_name> ...] ;
	func_def

arg_decl:
	([var_type <arg_name> [= const_item] [, ...] )

var_type_decl:
	var_type var_decl [, var_decl ...]

cond:
	( expr ) // expr returns must return bool

var_type:
	simple_var_type [&]
	void
	string
	<class_name>

simple_var_type:
	bool
	char
	int
	float

var_decl:
	<var_name> [ = expr ]

expr<END>:
	expr_part [op expr_part ...] <END>

expr_part:
	[pre_op ...] item / ( expr ) [post_op]

item:
	const_item
	<var_name>
	<func> args
	<class_name> args

const_item:
	<int>
	<float>
	<char>
	<string>
	const

args:
	( expr [, expr ...] )

pre_op:
	unary_op
	inc_dec_op

post_op:
	index_op
	inc_dec_op

op:
	base_op
	is
	==
	!=
	>
	>=
	<
	<=
	&&
	||
	!
	( expr )
	. <obj_func> args
	. <obj_member>
	[base_op]=
	=
	++
	--

base_op:
	+
	-
	*
	/
	%
	&
	|
	^
	>>
	<<

unary_op:
	+
	-
	!
	~

inc_dec_op:
	++
	--

index_op:
	[ expr ]

const:
	true
	false
